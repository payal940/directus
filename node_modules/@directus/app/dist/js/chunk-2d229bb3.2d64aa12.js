(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d229bb3"],{df61:function(t,n,e){"use strict";e.r(n),n["default"]='# Filter Rules\n\n> Permissions, validation, and the API\'s `filter` parameter all rely on a specific JSON structure to\n> define their rules. This page describes the syntax for creating flat, relational, or complex\n> filter rules.\n\n@TODO check+extend\n\n## Syntax\n\n-   **Field** — Any valid root field, [relational field](/reference/filter-rules#relational), or [logical operator](/reference/filter-rules#logical-operators)\n-   **Operator** — Any valid [API operator](/reference/filter-rules#supported-operators) prefaced with an underscore\n-   **Value** — Any valid static value, or [dynamic variable](/reference/filter-rules#dynamic-variables)\n\n```\n{\n\t<field>: {\n\t\t<operator>: <value>\n\t}\n}\n```\n\n### Examples\n\n```json\n{\n\t"title": {\n\t\t"_contains": "Directus"\n\t}\n}\n```\n\n```json\n{\n\t"owner": {\n\t\t"_eq": "$CURRENT_USER"\n\t}\n}\n```\n\n```json\n{\n\t"datetime": {\n\t\t"_lte": "$NOW"\n\t}\n}\n```\n\n## Supported Operators\n\n| Operator             | Description                               |\n| -------------------- | ----------------------------------------- |\n| `eq`                 | Equal to                                  |\n| `neq`                | Not equal to                              |\n| `lt`                 | Less than                                 |\n| `lte`                | Less than or equal to                     |\n| `gt`                 | Greater than                              |\n| `gte`                | Greater than or equal to                  |\n| `in`                 | Exists in one of the values               |\n| `nin`                | Not in one of the values                  |\n| `null`               | It is null                                |\n| `nnull`              | It is not null                            |\n| `contains`, `like`   | Contains the substring                    |\n| `ncontains`, `nlike` | Doesn\'t contain the substring             |\n| `rlike`              | Contains a substring using a wildcard     |\n| `nrlike`             | Not contains a substring using a wildcard |\n| `between`            | The value is between two values           |\n| `nbetween`           | The value is not between two values       |\n| `empty`              | The value is empty (null or falsy)        |\n| `nempty`             | The value is not empty (null or falsy)    |\n| `all`                | Contains all given related item\'s IDs     |\n| `has`                | Has one or more related items\'s IDs       |\n\n## Relational\n\nYou can target related values by nesting field names. For example, if you have a relational\n[Many-to-One](/guides/field-types/many-to-one-field) `author` field, you can set a rule for the\n`author.name` field using the following syntax.\n\n```json\n{\n\t"author": {\n\t\t"name": {\n\t\t\t"_eq": "Rijk van Zanten"\n\t\t}\n\t}\n}\n```\n\n## Logical Operators\n\nYou can nest or group multiple rules using the `_and` or `_or` logical operators. Each operator\nholds an array of rules, allowing for more complex filtering.\n\n```json\n{\n\t"_or": [\n\t\t{\n\t\t\t"_and": [\n\t\t\t\t{\n\t\t\t\t\t"owner": {\n\t\t\t\t\t\t"_eq": "$CURRENT_USER"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t"status": {\n\t\t\t\t\t\t"_in": ["published", "draft"]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\t"_and": [\n\t\t\t\t{\n\t\t\t\t\t"owner": {\n\t\t\t\t\t\t"_neq": "$CURRENT_USER"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t"status": {\n\t\t\t\t\t\t"_in": ["published"]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]\n}\n```\n\n## Dynamic Variables\n\nIn addition to static values, you can also filter against _dynamic_ values using the following\nvariables.\n\n-   `$CURRENT_USER` — The primary key of the currently authenticated user\n-   `$CURRENT_ROLE` — The primary key of the role for the currently authenticated user\n-   `$NOW` — The current timestamp\n'}}]);