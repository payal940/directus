(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d21a3f7"],{bb67:function(e,n,t){"use strict";t.r(n),n["default"]='# Relationships\n\n> As you might have guessed, relationships are a crucial part of any relational database. Directus\n> supports all standard relationship types, as well as a few more _compound_ types that offer\n> greater flexibility.\n\n## Understanding Relationships\n\nWhile it may seem complex at first, relational data is actually quite straightforward once you\nunderstand what\'s happening behind the confusing terminology. Before diving into the details of each\ntype, let\'s first cover a few basics that will help you better visualize each in your mind\'s eye.\n\n### PKs vs FKs\n\nEvery [item](/concepts/platform-overview#items) in a relational database has a unique "key" that\nidentifies it within its [collection](/concepts/platform-overview#collections). Because it\'s\nrequired, the key is the first [field](/concepts/platform-overview#fields) created within a\ncollection, typically storing an "auto-increment" number, an automatically generated unique hash, or\na manually entered value. They are often abbreviated to "PK" (Primary Key), "ID" (Identifier), "UID"\n(Unique Identifier), or "UUID" (Universally Unique Identifier), depending on the type of value they\nstore. After it\'s created, the value of an item\'s PK should _never_ change.\n\nTo link items together relationally, you simply save a reference of an item\'s PK in a different\nfield. That _reference_ is called a Foreign Key (FK).\n\n\x3c!-- prettier-ignore-start --\x3e\n::: tip Compound Keys\nWe\'ve ignored compound keys in this explanation to help keep things as simple as\npossible.\n:::\n\x3c!-- prettier-ignore-end --\x3e\n\n### Perspective Matters\n\nJust like primary and foreign keys are directional, relationships are always relative to their\n"parent" collection. Looking at the same relationship/key from the perspective of a different\ncollection may change or reverse its type.\n\n## Many-to-One (M2O)\n\nA Many-to-One (M2O) relationship exists on a field that saves a single FK. For example, a _city_ can\nonly be in one _country_, but a _country_ can have many _cities_. So the M2O data model would look\nlike this:\n\n```\ncities ("Many" Collection)\n- id (PK)\n- name\n- country (M2O that stores the FK to a country)\n\ncountry ("One" Collection)\n- id (PK, the value saved to "cities.country")\n- name\n```\n\n## One-to-Many (O2M)\n\nA One-to-Many (O2M) relationship uses an alias field to reference one or more FKs in a M2O. This is\nthe _exact same_ relationship as the M2O above, but looking at it from the opposite perspective (see\n[Perspective Matters](#perspective-matters)). So the O2M data model is the same, but adds an alias\n"cities" field to the Country collection, like this:\n\n```\ncountry ("One" Collection)\n- id (PK, the value saved to "cities.country")\n- name\n- *cities* (O2M alias field that pulls in references from "cities.country")\n\ncities ("Many" Collection)\n- id (PK)\n- name\n- country (stores the FK to a country)\n```\n\n\x3c!-- prettier-ignore-start --\x3e\n::: tip\nManual Reordering To enable manual reordering for a O2M, simply add a field with the `sort` type\nto the "many" side (`cities` in the above example).\n:::\n\x3c!-- prettier-ignore-end --\x3e\n\n\x3c!-- prettier-ignore-start --\x3e\n::: tip Translations\nThe Translations interface allows [creating multilingual content](/concepts/internationalization#content-translations) relationally.\nIt is a standard O2M relationship, but also includes an additional field on the "many" collection to\nhold the language key\n:::\n\x3c!-- prettier-ignore-end --\x3e\n\n## Many-to-Many (M2M)\n\nA Many-to-Many (M2M) relationship uses a "Junction Table" to connect many items from one collection,\nto many items of another collection. For example, a _recipe_ can have many _ingredients_, and\n_ingredients_ can be in many _recipes_. So the M2M data model would look like this:\n\n```\nrecipes (Collection)\n- id (PK, the value saved to "recipe_ingredients.recipe")\n- name\n- *ingredients* (M2M/O2M alias field that pulls in references from recipe_ingredients)\n\ningredients (Collection)\n- id (PK, the value saved to "recipe_ingredients.ingredient")\n- name\n- *recipes* (M2M/O2M alias field that pulls in references from recipe_ingredients)\n\nrecipe_ingredients (Junction Collection)\n- id (PK)\n- recipe (stores the FK to a recipe)\n- ingredient (stores the FK to a ingredient)\n- quantity\n```\n\nNotice that the example above also has a `quantity` field on the junction table. You can add any\ncontextual fields to the junction, and they will also be included in the App\'s relational edit form.\n\n\x3c!-- prettier-ignore-start --\x3e\n::: warning M2M == O2Mx2\nAn M2M is technically two relationships viewed as one. Each side has a O2M\nto the Junction Table that sits in the middle. In that sense, there really is no "M2M".\n:::\n\x3c!-- prettier-ignore-end --\x3e\n\n\x3c!-- prettier-ignore-start --\x3e\n::: tip\nManual Reordering To enable manual reordering for a M2M, simply add a numeric field to the\njunction table and set it as the [Collection Sort](/guides/collections#sort).\n:::\n\x3c!-- prettier-ignore-end --\x3e\n\n\x3c!-- prettier-ignore-start --\x3e\n::: tip\nSelf-Referencing You can also have a M2M relationship that connects items within the _same_\ncollection. A common example of this is "Related Articles", where each article might relate to many\nother articles.\n:::\n\x3c!-- prettier-ignore-end --\x3e\n\n## One-to-One (O2O)\n\nDirectus does not include a one-to-one (O2O) relationship type or interface. However, O2O is\nessentially the same as a M2O (storing a foreign key). The only difference is that a O2O enforces\nthe cardinality. In other words, selecting a relational item in a O2O means that item can not be\nselected elsewhere (it can only be used once). This functionality can be added by checking and\nconstraining uniqueness via a [custom event hook](/concepts/api-extensions) or\n[custom interface](/concepts/app-extensions).\n\nAn example of a O2O is: a _person_ only has one unique set of _fingerprints_, and those\n_fingerprints_ only belong to one _person_.\n\n## Many-to-Any (M2A)\n\nSometimes called a "matrix field" or "replicator", the Many-to-Any (M2A) relationship is essentially\nthe same as a M2M, but with one crucial difference: the junction table also stores the _parent\ncollection name of the FK_. This "compound key" combines the collection name and FK to provide a\nunique reference to _any_ other item within the project. You can then artificially limit which\ncollections are valid through an "allow list".\n\nAn example of a M2A is a "page layout builder". These typically will have modular components across\nseveral different collections (eg: "Heading", "Text Block", "Media Asset", etc), and a _Pages_\ncollections where you can piece them together. Therefore, the junction table will link a specific\npage with specific components, allowing the creation of relational page layouts.\n\n---\n\n@TODO\n\n```\n[ ] o2o\n[x] m2o           (dropdown)\n[x] o2m           (table, repeater)\n\n[x] m2m [o2m-m2o] (table, repeater)\n\n[ ] o2a           (builder)\n[x] a2o\n\n[x] m2a [o2m-a2o] (builder)\n[ ] a2m [o2a-m2o]\n[ ] a2a [o2a-a2o] (dynamic builder)\n```'}}]);